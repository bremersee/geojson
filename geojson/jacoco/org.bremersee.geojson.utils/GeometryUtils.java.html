<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GeometryUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GeoJSON</a> &gt; <a href="index.source.html" class="el_package">org.bremersee.geojson.utils</a> &gt; <span class="el_source">GeometryUtils.java</span></div><h1>GeometryUtils.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2015-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.bremersee.geojson.utils;

import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.io.UnsupportedEncodingException;
import java.math.BigDecimal;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import org.locationtech.jts.geom.Coordinate;
import org.locationtech.jts.geom.CoordinateSequence;
import org.locationtech.jts.geom.Geometry;
import org.locationtech.jts.geom.GeometryCollection;
import org.locationtech.jts.geom.GeometryFactory;
import org.locationtech.jts.geom.LineString;
import org.locationtech.jts.geom.LinearRing;
import org.locationtech.jts.geom.MultiLineString;
import org.locationtech.jts.geom.MultiPoint;
import org.locationtech.jts.geom.MultiPolygon;
import org.locationtech.jts.geom.Point;
import org.locationtech.jts.geom.Polygon;
import org.locationtech.jts.geom.impl.CoordinateArraySequenceFactory;
import org.locationtech.jts.io.ParseException;
import org.locationtech.jts.io.WKTReader;

/**
 * Utility methods for geometry objects.
 *
 * @author Christian Bremer
 */
@SuppressWarnings({&quot;unused&quot;, &quot;WeakerAccess&quot;})
public abstract class GeometryUtils {

  /**
   * Never construct.
   */
  private GeometryUtils() {
  }

  /**
   * The earth radius in meters.
   */
  public static final double EARTH_RADIUS_METERS = 6378137.;

  /**
   * Maximum latitude for mercator projection.
   */
  public static final double MERCATOR_MAX_LAT = 85.05112878;

  /**
   * Minimum latitude for mercator projection.
   */
  public static final double MERCATOR_MIN_LAT = -85.05112878;

  /**
   * Default spatial authority: 'EPSG'.
   */
  public static final String DEFAULT_SPATIAL_AUTHORITY = &quot;EPSG&quot;;

  /**
   * Reference ID of WGS84: '4326'.
   */
  public static final int WGS84_SPATIAL_REFERENCE_ID = 4326;

  /**
   * CRS (Coordinate reference system) of WGS84: 'EPSG:4326'.
   */
  public static final String WGS84_CRS =
      DEFAULT_SPATIAL_AUTHORITY + &quot;:&quot; + WGS84_SPATIAL_REFERENCE_ID;

  /**
   * Reference ID of mercator projection: '3857'.
   */
  public static final int MERCATOR_SPATIAL_REFERENCE_ID = 3857;

  /**
   * Alternative reference ID of mercator: '900913'.
   */
  public static final int MERCATOR_SPATIAL_REFERENCE_ID_ALT = 900913;

  /**
   * CRS (Coordinate reference system) of mercator: 'EPSG:3857'.
   */
  public static final String MERCATOR_CRS =
      DEFAULT_SPATIAL_AUTHORITY + &quot;:&quot; + MERCATOR_SPATIAL_REFERENCE_ID;

  /**
   * Alternative CRS (Coordinate reference system) of mercator: 'EPSG:900913'.
   */
  public static final String MERCATOR_CRS_ALT =
      DEFAULT_SPATIAL_AUTHORITY + &quot;:&quot; + MERCATOR_SPATIAL_REFERENCE_ID_ALT;

  /**
   * Default geometry factory.
   */
<span class="fc" id="L114">  private static final GeometryFactory DEFAULT_GEOMETRY_FACTORY = new GeometryFactory();</span>

  /**
   * Checks whether two geometry objects are equal.
   *
   * &lt;p&gt;Because the {@link GeometryCollection#equals(Geometry)} method throws an exception, this
   * method is used in the GeoJSON classes.
   *
   * @param g1 one geometry
   * @param g2 another geometry
   * @return &lt;code&gt;true&lt;/code&gt; if the geometries are equal otherwise &lt;code&gt;false&lt;/code&gt;
   */
  public static boolean equals(final Geometry g1, final Geometry g2) { // NOSONAR
<span class="pc bpc" id="L127" title="3 of 4 branches missed.">    if (g1 == null &amp;&amp; g2 == null) {</span>
<span class="nc" id="L128">      return true;</span>
    }
<span class="pc bpc" id="L130" title="2 of 4 branches missed.">    if (g1 == null || g2 == null) {</span>
<span class="nc" id="L131">      return false;</span>
    }
<span class="pc bpc" id="L133" title="1 of 2 branches missed.">    if (g1 == g2) {</span>
<span class="nc" id="L134">      return true;</span>
    }
<span class="pc bpc" id="L136" title="1 of 4 branches missed.">    if (g1 instanceof GeometryCollection &amp;&amp; g2 instanceof GeometryCollection) {</span>
<span class="fc" id="L137">      return equals((GeometryCollection) g1, (GeometryCollection) g2);</span>
    }
    try {
<span class="fc" id="L140">      return g1.equals(g2);</span>
<span class="nc" id="L141">    } catch (Throwable t) { // NOSONAR</span>
<span class="nc" id="L142">      return false;</span>
    }
  }

  /**
   * Checks whether two geometry collections are equal.
   *
   * @param gc1 one geometry collection
   * @param gc2 another geometry collection
   * @return &lt;code&gt;true&lt;/code&gt; if the geometry collections are equal otherwise
   * &lt;code&gt;false&lt;/code&gt;
   */
  private static boolean equals(final GeometryCollection gc1, final GeometryCollection gc2) {
<span class="pc bpc" id="L155" title="3 of 4 branches missed.">    if (gc1 == null &amp;&amp; gc2 == null) {</span>
<span class="nc" id="L156">      return true;</span>
    }
<span class="pc bpc" id="L158" title="2 of 4 branches missed.">    if (gc1 == null || gc2 == null) {</span>
<span class="nc" id="L159">      return false;</span>
    }
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">    if (gc1.getNumGeometries() != gc2.getNumGeometries()) {</span>
<span class="nc" id="L162">      return false;</span>
    }
<span class="fc bfc" id="L164" title="All 2 branches covered.">    for (int i = 0; i &lt; gc1.getNumGeometries(); i++) {</span>
<span class="fc" id="L165">      Geometry g1 = gc1.getGeometryN(i);</span>
<span class="fc" id="L166">      Geometry g2 = gc2.getGeometryN(i);</span>
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">      if (!equals(g1, g2)) {</span>
<span class="nc" id="L168">        return false;</span>
      }
    }
<span class="fc" id="L171">    return true;</span>
  }

  /**
   * Calculate the bounding box of the specified geometry (see
   * &lt;a href=&quot;https://tools.ietf.org/html/rfc7946#section-5&quot;&gt;bounding-boxes&lt;/a&gt;).
   *
   * &lt;p&gt;A GeoJSON object MAY have a member named &quot;bbox&quot; to include information on the coordinate
   * range for its Geometries, Features, or FeatureCollections.  The value of the bbox member MUST
   * be an array of length 2*n where n is the number of dimensions represented in the contained
   * geometries, with all axes of the most southwesterly point followed by all axes of the more
   * northeasterly point. The axes order of a bbox follows the axes order of geometries.
   *
   * @param geometry the geometry
   * @return {@code null} if the bounding box can not be calculated, otherwise the bounding box
   */
  public static double[] getBoundingBox(final Geometry geometry) {
<span class="fc bfc" id="L188" title="All 2 branches covered.">    if (geometry == null) {</span>
<span class="fc" id="L189">      return null;</span>
    }
<span class="fc" id="L191">    return getBoundingBox(Collections.singletonList(geometry));</span>
  }

  /**
   * Calculate the bounding box of the specified geometries.
   *
   * @param geometries the geometries
   * @return {@code null} if the bounding box can not be calculated, otherwise the bounding box
   */
  public static double[] getBoundingBox(final Collection&lt;? extends Geometry&gt; geometries) {
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">    if (geometries == null</span>
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">        || geometries.isEmpty()) {</span>
<span class="nc" id="L203">      return null;</span>
    }
<span class="fc" id="L205">    double minX = Double.NaN;</span>
<span class="fc" id="L206">    double minY = Double.NaN;</span>
<span class="fc" id="L207">    double minZ = Double.NaN;</span>
<span class="fc" id="L208">    double maxX = Double.NaN;</span>
<span class="fc" id="L209">    double maxY = Double.NaN;</span>
<span class="fc" id="L210">    double maxZ = Double.NaN;</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">    for (final Geometry geometry : geometries) {</span>
<span class="pc bpc" id="L212" title="2 of 4 branches missed.">      if (geometry != null &amp;&amp; geometry.getCoordinates() != null) {</span>
<span class="fc" id="L213">        final Coordinate[] coords = geometry.getCoordinates();</span>
        //noinspection ForLoopReplaceableByForEach
<span class="fc bfc" id="L215" title="All 2 branches covered.">        for (int i = 0; i &lt; coords.length; i++) {</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">          if (Double.isNaN(minX)) {</span>
<span class="fc" id="L217">            minX = coords[i].getX();</span>
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">          } else if (!Double.isNaN(coords[i].getX())) {</span>
<span class="fc" id="L219">            minX = Math.min(minX, coords[i].getX());</span>
          }
<span class="fc bfc" id="L221" title="All 2 branches covered.">          if (Double.isNaN(minY)) {</span>
<span class="fc" id="L222">            minY = coords[i].getY();</span>
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">          } else if (!Double.isNaN(coords[i].getY())) {</span>
<span class="fc" id="L224">            minY = Math.min(minY, coords[i].getY());</span>
          }
<span class="fc bfc" id="L226" title="All 2 branches covered.">          if (Double.isNaN(minZ)) {</span>
<span class="fc" id="L227">            minZ = coords[i].getZ();</span>
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">          } else if (!Double.isNaN(coords[i].getZ())) {</span>
<span class="fc" id="L229">            minZ = Math.min(minZ, coords[i].getZ());</span>
          }

<span class="fc bfc" id="L232" title="All 2 branches covered.">          if (Double.isNaN(maxX)) {</span>
<span class="fc" id="L233">            maxX = coords[i].getX();</span>
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">          } else if (!Double.isNaN(coords[i].getX())) {</span>
<span class="fc" id="L235">            maxX = Math.max(maxX, coords[i].getX());</span>
          }
<span class="fc bfc" id="L237" title="All 2 branches covered.">          if (Double.isNaN(maxY)) {</span>
<span class="fc" id="L238">            maxY = coords[i].getY();</span>
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">          } else if (!Double.isNaN(coords[i].getY())) {</span>
<span class="fc" id="L240">            maxY = Math.max(maxY, coords[i].getY());</span>
          }
<span class="fc bfc" id="L242" title="All 2 branches covered.">          if (Double.isNaN(maxZ)) {</span>
<span class="fc" id="L243">            maxZ = coords[i].getZ();</span>
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">          } else if (!Double.isNaN(coords[i].getZ())) {</span>
<span class="fc" id="L245">            maxZ = Math.max(maxZ, coords[i].getZ());</span>
          }
        }
      }
<span class="fc" id="L249">    }</span>
<span class="pc bpc" id="L250" title="4 of 8 branches missed.">    if (!Double.isNaN(minX) &amp;&amp; !Double.isNaN(maxX) &amp;&amp; !Double.isNaN(minY) &amp;&amp; !Double.isNaN(maxY)) {</span>
<span class="pc bpc" id="L251" title="1 of 4 branches missed.">      if (!Double.isNaN(minZ) &amp;&amp; !Double.isNaN(maxZ)) {</span>
<span class="fc" id="L252">        return new double[]{minX, minY, minZ, maxX, maxY, maxZ};</span>
      }
<span class="fc" id="L254">      return new double[]{minX, minY, maxX, maxY};</span>
    }
<span class="nc" id="L256">    return null;</span>
  }

  /**
   * Returns the coordinate in the south-west.
   *
   * @param boundingBox the bounding box
   * @return the coordinate in the south-west
   */
  public static Coordinate getSouthWest(final double[] boundingBox) {
<span class="nc bnc" id="L266" title="All 6 branches missed.">    if (boundingBox == null || !(boundingBox.length == 4 || boundingBox.length == 6)) {</span>
<span class="nc" id="L267">      return null;</span>
    }
<span class="nc" id="L269">    return createCoordinate(boundingBox[0], boundingBox[1]); // southWest</span>
  }

  /**
   * Returns the coordinate in the north-west.
   *
   * @param boundingBox the bounding box
   * @return the coordinate in the north-west
   */
  public static Coordinate getNorthWest(final double[] boundingBox) {
<span class="nc bnc" id="L279" title="All 6 branches missed.">    if (boundingBox == null || !(boundingBox.length == 4 || boundingBox.length == 6)) {</span>
<span class="nc" id="L280">      return null;</span>
    }
<span class="nc bnc" id="L282" title="All 2 branches missed.">    if (boundingBox.length == 6) {</span>
      // 0 1 2 3 4 5
      // x0, y0, z0, x1, y1, z1
<span class="nc" id="L285">      return createCoordinate(boundingBox[0], boundingBox[4]);</span>
    } else {
      // 0 1 2 3
      // x0, y0, x1, y1
<span class="nc" id="L289">      return createCoordinate(boundingBox[0], boundingBox[3]);</span>
    }
  }

  /**
   * Returns the coordinate in the north-east.
   *
   * @param boundingBox the bounding box
   * @return the coordinate in the north-east
   */
  public static Coordinate getNorthEast(final double[] boundingBox) {
<span class="nc bnc" id="L300" title="All 6 branches missed.">    if (boundingBox == null || !(boundingBox.length == 4 || boundingBox.length == 6)) {</span>
<span class="nc" id="L301">      return null;</span>
    }
<span class="nc bnc" id="L303" title="All 2 branches missed.">    if (boundingBox.length == 6) {</span>
      // 0 1 2 3 4 5
      // x0, y0, z0, x1, y1, z1
<span class="nc" id="L306">      return createCoordinate(boundingBox[3], boundingBox[4]);</span>
    } else {
      // 0 1 2 3
      // x0, y0, x1, y1
<span class="nc" id="L310">      return createCoordinate(boundingBox[2], boundingBox[3]);</span>
    }
  }

  /**
   * Returns the coordinate in the south-east.
   *
   * @param boundingBox the bounding box
   * @return the coordinate in the south-east
   */
  public static Coordinate getSouthEast(final double[] boundingBox) {
<span class="nc bnc" id="L321" title="All 6 branches missed.">    if (boundingBox == null || !(boundingBox.length == 4 || boundingBox.length == 6)) {</span>
<span class="nc" id="L322">      return null;</span>
    }
<span class="nc bnc" id="L324" title="All 2 branches missed.">    if (boundingBox.length == 6) {</span>
      // 0 1 2 3 4 5
      // x0, y0, z0, x1, y1, z1
<span class="nc" id="L327">      return createCoordinate(boundingBox[3], boundingBox[1]);</span>
    } else {
      // 0 1 2 3
      // x0, y0, x1, y1
<span class="nc" id="L331">      return createCoordinate(boundingBox[2], boundingBox[1]);</span>
    }
  }

  /**
   * Returns a polygon from the bounding box.
   *
   * @param boundingBox the bounding bos
   * @return the polygon or {@code null} if the bounding box is {@code null} or empty
   */
  public static Polygon getBoundingBoxAsPolygon2D(final double[] boundingBox) {
<span class="nc" id="L342">    return getBoundingBoxAsPolygon2D(boundingBox, null);</span>
  }

  /**
   * Returns a polygon from the bounding box.
   *
   * @param boundingBox     the bounding bos
   * @param geometryFactory the geometry factory
   * @return the polygon or {@code null} if the bounding box is {@code null} or empty
   */
  public static Polygon getBoundingBoxAsPolygon2D(final double[] boundingBox,
      final GeometryFactory geometryFactory) {
<span class="nc" id="L354">    final Coordinate sw = getSouthWest(boundingBox);</span>
<span class="nc" id="L355">    final Coordinate se = getSouthEast(boundingBox);</span>
<span class="nc" id="L356">    final Coordinate ne = getNorthEast(boundingBox);</span>
<span class="nc" id="L357">    final Coordinate nw = getNorthWest(boundingBox);</span>
<span class="nc bnc" id="L358" title="All 8 branches missed.">    if (sw == null || se == null || ne == null || nw == null) {</span>
<span class="nc" id="L359">      return null;</span>
    }
<span class="nc" id="L361">    float x1 = (float) sw.getX();</span>
<span class="nc" id="L362">    float x2 = (float) se.getX();</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">    if (x1 == x2) {</span>
<span class="nc" id="L364">      return null;</span>
    }
<span class="nc" id="L366">    float y1 = (float) sw.getY();</span>
<span class="nc" id="L367">    float y2 = (float) nw.getY();</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">    if (y1 == y2) {</span>
<span class="nc" id="L369">      return null;</span>
    }
<span class="nc" id="L371">    return createPolygon(</span>
<span class="nc" id="L372">        createLinearRing(Arrays.asList(sw, se, ne, nw, sw), geometryFactory),</span>
        geometryFactory);
  }

  /**
   * Returns the bounding box of the geometry as polygon.
   *
   * @param geometry the geometry
   * @return the bounding box of the geometry as polygon
   */
  public static Polygon getBoundingBoxAsPolygon2D(final Geometry geometry) {
<span class="nc" id="L383">    return getBoundingBoxAsPolygon2D(geometry, null);</span>
  }

  /**
   * Returns the bounding box of the geometry as polygon.
   *
   * @param geometry        the geometry
   * @param geometryFactory the geometry factory to use
   * @return the bounding box of the geometry as polygon
   */
  @SuppressWarnings(&quot;SameParameterValue&quot;)
  public static Polygon getBoundingBoxAsPolygon2D(
      final Geometry geometry,
      final GeometryFactory geometryFactory) {

<span class="nc" id="L398">    final double[] bbox = getBoundingBox(geometry);</span>
<span class="nc bnc" id="L399" title="All 6 branches missed.">    if (bbox == null || !(bbox.length == 4 || bbox.length == 6)) {</span>
<span class="nc" id="L400">      return null;</span>
    }

<span class="nc bnc" id="L403" title="All 2 branches missed.">    int add = bbox.length == 6 ? 1 : 0;</span>
<span class="nc" id="L404">    Double a = bbox[0];</span>
<span class="nc" id="L405">    Double b = bbox[2 + add];</span>
<span class="nc" id="L406">    Double c = bbox[1];</span>
<span class="nc" id="L407">    Double d = bbox[3 + add];</span>
<span class="nc bnc" id="L408" title="All 4 branches missed.">    if (a.equals(b) || c.equals(d)) {</span>
<span class="nc" id="L409">      return null;</span>
    }

<span class="nc" id="L412">    Coordinate c0 = getSouthWest(bbox);</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">    if (c0 == null) {</span>
<span class="nc" id="L414">      throw new IllegalArgumentException(&quot;South west coordinate is null.&quot;);</span>
    }
<span class="nc" id="L416">    Coordinate c1 = getNorthWest(bbox);</span>
<span class="nc" id="L417">    Coordinate c2 = getNorthEast(bbox);</span>
<span class="nc" id="L418">    Coordinate c3 = getSouthEast(bbox);</span>

<span class="nc bnc" id="L420" title="All 2 branches missed.">    final GeometryFactory gf = geometryFactory == null ? DEFAULT_GEOMETRY_FACTORY : geometryFactory;</span>
<span class="nc" id="L421">    return gf.createPolygon(new Coordinate[]{c0, c1, c2, c3, (Coordinate) c0.clone()});</span>
  }

  /**
   * Returns the Well-known Text representation of this Geometry. For a definition of the Well-known
   * Text format, see the OpenGIS Simple Features Specification.
   *
   * @param geometry the geometry
   * @return the Well-known Text representation of this Geometry
   */
  public static String toWKT(final Geometry geometry) {
<span class="nc bnc" id="L432" title="All 2 branches missed.">    if (geometry == null) {</span>
<span class="nc" id="L433">      return null;</span>
    }
<span class="nc" id="L435">    return geometry.toText();</span>
  }

  /**
   * Reads a Well-Known Text representation of a Geometry from a {@link String}.
   *
   * @param wkt one or more strings (see the OpenGIS Simple Features Specification) separated by
   *            whitespace
   * @return a Geometry specified by wellKnownText
   * @throws RuntimeException if a parsing problem occurs
   */
  public static Geometry fromWKT(final String wkt) throws RuntimeException {
<span class="fc" id="L447">    return fromWKT(wkt, null);</span>
  }

  /**
   * Reads a Well-Known Text representation of a Geometry from a {@link String}.
   *
   * @param wkt             one or more strings (see the OpenGIS Simple Features Specification)
   *                        separated by whitespace
   * @param geometryFactory the geometry factory to use
   * @return a Geometry specified by wellKnownText
   * @throws RuntimeException if a parsing problem occurs
   */
  @SuppressWarnings(&quot;SameParameterValue&quot;)
  public static Geometry fromWKT(final String wkt, final GeometryFactory geometryFactory)
      throws RuntimeException {

<span class="pc bpc" id="L463" title="2 of 4 branches missed.">    if (wkt == null || wkt.trim().length() == 0) {</span>
<span class="nc" id="L464">      return null;</span>
    }
<span class="pc bpc" id="L466" title="1 of 2 branches missed.">    final GeometryFactory gf = geometryFactory == null ? DEFAULT_GEOMETRY_FACTORY : geometryFactory;</span>
<span class="fc" id="L467">    WKTReader wktReader = new WKTReader(gf);</span>
    try {
<span class="fc" id="L469">      return wktReader.read(wkt);</span>
<span class="nc" id="L470">    } catch (ParseException e) {</span>
<span class="nc" id="L471">      throw new RuntimeException(&quot;Parsing WKT [&quot; + wkt + &quot;] failed.&quot;, e);</span>
    }
  }

  /**
   * Reads a Well-Known Text representation of a Geometry from a {@link Reader}.
   *
   * @param reader a {@link Reader} which will return a string (see the OpenGIS Simple Features
   *               Specification)
   * @return a Geometry read from reader
   * @throws RuntimeException if a parsing problem occurs
   */
  public static Geometry fromWKT(final Reader reader) throws RuntimeException {
<span class="nc" id="L484">    return fromWKT(reader, null);</span>
  }

  /**
   * Reads a Well-Known Text representation of a Geometry from a {@link Reader}.
   *
   * @param reader          a {@link Reader} which will return a string (see the OpenGIS Simple
   *                        Features Specification)
   * @param geometryFactory the geometry factory to use
   * @return a Geometry read from reader
   * @throws RuntimeException if a parsing problem occurs
   */
  @SuppressWarnings(&quot;SameParameterValue&quot;)
  public static Geometry fromWKT(final Reader reader, final GeometryFactory geometryFactory)
      throws RuntimeException {

<span class="nc bnc" id="L500" title="All 2 branches missed.">    if (reader == null) {</span>
<span class="nc" id="L501">      return null;</span>
    }
<span class="nc bnc" id="L503" title="All 2 branches missed.">    final GeometryFactory gf = geometryFactory == null ? DEFAULT_GEOMETRY_FACTORY : geometryFactory;</span>
<span class="nc" id="L504">    WKTReader wktReader = new WKTReader(gf);</span>
    try {
<span class="nc" id="L506">      return wktReader.read(reader);</span>
<span class="nc" id="L507">    } catch (ParseException e) {</span>
<span class="nc" id="L508">      throw new RuntimeException(&quot;Parsing WKT failed.&quot;, e);</span>
    }
  }

  /**
   * Reads a Well-Known Text representation of a Geometry from an {@link InputStream}.
   *
   * @param inputStream an {@link InputStream} which will return a string (see the OpenGIS Simple
   *                    Features Specification)
   * @param charsetName the charset to use
   * @return a Geometry read from the input stream
   * @throws RuntimeException if a parsing problem occurs
   */
  public static Geometry fromWKT(final InputStream inputStream, final String charsetName)
      throws RuntimeException {
<span class="nc" id="L523">    return fromWKT(inputStream, charsetName, null);</span>
  }

  /**
   * Reads a Well-Known Text representation of a Geometry from an {@link InputStream}.
   *
   * @param inputStream     an {@link InputStream} which will return a string (see the OpenGIS
   *                        Simple Features Specification)
   * @param charsetName     the charset to use
   * @param geometryFactory the geometry factory to use
   * @return a Geometry read from the input stream
   * @throws RuntimeException if a parsing problem occurs
   */
  @SuppressWarnings(&quot;SameParameterValue&quot;)
  public static Geometry fromWKT(final InputStream inputStream, final String charsetName,
      final GeometryFactory geometryFactory)
      throws RuntimeException {
<span class="nc bnc" id="L540" title="All 2 branches missed.">    if (inputStream == null) {</span>
<span class="nc" id="L541">      return null;</span>
    }
<span class="nc bnc" id="L543" title="All 2 branches missed.">    final String cn =</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">        charsetName == null || charsetName.trim().length() == 0 ? StandardCharsets.UTF_8.name()</span>
            : charsetName;
<span class="nc bnc" id="L546" title="All 2 branches missed.">    final GeometryFactory gf = geometryFactory == null ? DEFAULT_GEOMETRY_FACTORY : geometryFactory;</span>
    try {
<span class="nc" id="L548">      return fromWKT(new InputStreamReader(inputStream, cn), gf);</span>
<span class="nc" id="L549">    } catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L550">      throw new RuntimeException(&quot;Parsing WKT failed.&quot;, e);</span>
    }
  }

  /**
   * Creates a coordinate.
   *
   * @param x the x value
   * @param y the y value
   * @return the coordinate
   */
  public static Coordinate createCoordinate(final double x, final double y) {
<span class="nc" id="L562">    return new Coordinate(x, y);</span>
  }

  /**
   * Creates a coordinate.
   *
   * @param x the x value
   * @param y the y value
   * @return the coordinate
   * @throws IllegalArgumentException if x or y is {@code null}
   */
  public static Coordinate createCoordinate(final BigDecimal x, final BigDecimal y) {
<span class="nc bnc" id="L574" title="All 2 branches missed.">    if (x == null) {</span>
<span class="nc" id="L575">      throw new IllegalArgumentException(&quot;X must not be null.&quot;);</span>
    }
<span class="nc bnc" id="L577" title="All 2 branches missed.">    if (y == null) {</span>
<span class="nc" id="L578">      throw new IllegalArgumentException(&quot;Y must not be null.&quot;);</span>
    }
<span class="nc" id="L580">    return new Coordinate(x.doubleValue(), y.doubleValue());</span>
  }

  /**
   * Creates a coordinate.
   *
   * @param latitude  the latitude value
   * @param longitude the longitude value
   * @return the coordinate
   */
  public static Coordinate createCoordinateWGS84(final double latitude, final double longitude) {
<span class="nc" id="L591">    return new Coordinate(longitude, latitude);</span>
  }

  /**
   * Creates a coordinate.
   *
   * @param latitude  the latitude value
   * @param longitude the longitude value
   * @return the coordinate
   * @throws IllegalArgumentException if latitude or longitude is {@code null}
   */
  public static Coordinate createCoordinateWGS84(
      final BigDecimal latitude, final BigDecimal longitude) {
<span class="nc bnc" id="L604" title="All 2 branches missed.">    if (latitude == null) {</span>
<span class="nc" id="L605">      throw new IllegalArgumentException(&quot;Latitude must not be null.&quot;);</span>
    }
<span class="nc bnc" id="L607" title="All 2 branches missed.">    if (longitude == null) {</span>
<span class="nc" id="L608">      throw new IllegalArgumentException(&quot;Longitude must not be null.&quot;);</span>
    }
<span class="nc" id="L610">    return new Coordinate(longitude.doubleValue(), latitude.doubleValue());</span>
  }

  /**
   * Gets latitude value of WGS84.
   *
   * @param coordinate the coordinate
   * @return the latitude
   */
  public static double getLatitudeWGS84(Coordinate coordinate) {
<span class="nc bnc" id="L620" title="All 2 branches missed.">    if (coordinate == null) {</span>
<span class="nc" id="L621">      throw new IllegalArgumentException(&quot;Coordinate must not be null.&quot;);</span>
    }
<span class="nc" id="L623">    return coordinate.getY();</span>
  }

  /**
   * Gets longitude value of WGS84.
   *
   * @param coordinate the coordinate
   * @return the longitude
   */
  public static double getLongitudeWGS84(final Coordinate coordinate) {
<span class="nc bnc" id="L633" title="All 2 branches missed.">    if (coordinate == null) {</span>
<span class="nc" id="L634">      throw new IllegalArgumentException(&quot;Coordinate must not be null.&quot;);</span>
    }
<span class="nc" id="L636">    return coordinate.getX();</span>
  }

  /**
   * Creates a point.
   *
   * @param x the x value
   * @param y the y value
   * @return the point
   */
  public static Point createPoint(final double x, final double y) {
<span class="nc" id="L647">    return createPoint(createCoordinate(x, y), null);</span>
  }

  /**
   * Creates a point.
   *
   * @param x               the x value
   * @param y               the y value
   * @param geometryFactory the geometry factory to use
   * @return the point
   */
  public static Point createPoint(final double x, final double y,
      final GeometryFactory geometryFactory) {
<span class="nc" id="L660">    return createPoint(createCoordinate(x, y), geometryFactory);</span>
  }

  /**
   * Creates a point.
   *
   * @param x the x value
   * @param y the y value
   * @return the point
   */
  public static Point createPoint(final BigDecimal x, final BigDecimal y) {
<span class="nc" id="L671">    return createPoint(createCoordinate(x, y), null);</span>
  }

  /**
   * Creates a point.
   *
   * @param x               the x value
   * @param y               the y value
   * @param geometryFactory the geometry factory to use
   * @return the point
   */
  public static Point createPoint(final BigDecimal x, final BigDecimal y,
      final GeometryFactory geometryFactory) {
<span class="nc" id="L684">    return createPoint(createCoordinate(x, y), geometryFactory);</span>
  }

  /**
   * Creates a Point using the given Coordinate; a null Coordinate will create an empty Geometry.
   *
   * @param coordinate the coordinate of the point
   * @return the point
   */
  public static Point createPoint(final Coordinate coordinate) {
<span class="fc" id="L694">    return createPoint(coordinate, null);</span>
  }

  /**
   * Creates a Point using the given Coordinate; a null Coordinate will create an empty Geometry.
   *
   * @param coordinate      the coordinate of the point
   * @param geometryFactory the geometry factory to use
   * @return the point
   */
  @SuppressWarnings(&quot;SameParameterValue&quot;)
  public static Point createPoint(final Coordinate coordinate,
      final GeometryFactory geometryFactory) {
<span class="pc bpc" id="L707" title="1 of 2 branches missed.">    final GeometryFactory gf = geometryFactory == null ? DEFAULT_GEOMETRY_FACTORY : geometryFactory;</span>
<span class="fc" id="L708">    return gf.createPoint(coordinate);</span>
  }

  /**
   * Creates a point from WGS84 latitude and longitude.&lt;br&gt; Latitude becomes the y-value.&lt;br&gt;
   * Longitude becomes the x-value.&lt;br&gt;
   *
   * @param latitude  the latitude in degrees
   * @param longitude the longitude in degrees
   * @return the point
   */
  public static Point createPointWGS84(final double latitude, final double longitude) {
<span class="nc" id="L720">    return createPoint(longitude, latitude, null);</span>
  }

  /**
   * Creates a point from WGS84 latitude and longitude.&lt;br&gt; Latitude becomes the y-value.&lt;br&gt;
   * Longitude becomes the x-value.&lt;br&gt;
   *
   * @param latitude  the latitude in degrees
   * @param longitude the longitude in degrees
   * @return the point
   */
  public static Point createPointWGS84(final BigDecimal latitude, final BigDecimal longitude) {
<span class="nc" id="L732">    return createPoint(longitude, latitude, null);</span>
  }

  /**
   * Creates a point from WGS84 latitude and longitude.&lt;br&gt; Latitude becomes the y-value.&lt;br&gt;
   * Longitude becomes the x-value.&lt;br&gt;
   *
   * @param latitude        the latitude in degrees
   * @param longitude       the longitude in degrees
   * @param geometryFactory the geometry factory to use
   * @return the point
   */
  public static Point createPointWGS84(final double latitude, final double longitude,
      final GeometryFactory geometryFactory) {
<span class="nc" id="L746">    return createPoint(longitude, latitude, geometryFactory);</span>
  }

  /**
   * Creates a point from WGS84 latitude and longitude.&lt;br&gt; Latitude becomes the y-value.&lt;br&gt;
   * Longitude becomes the x-value.&lt;br&gt;
   *
   * @param latitude        the latitude in degrees
   * @param longitude       the longitude in degrees
   * @param geometryFactory the geometry factory to use
   * @return the point
   */
  public static Point createPointWGS84(final BigDecimal latitude, final BigDecimal longitude,
      final GeometryFactory geometryFactory) {
<span class="nc" id="L760">    return createPoint(longitude, latitude, geometryFactory);</span>
  }

  /**
   * Creates a MultiPoint using the given Points. A null or empty collection will create an empty
   * MultiPoint.
   *
   * @param points the points of the {@link MultiPoint}
   * @return the {@link MultiPoint}
   */
  public static MultiPoint createMultiPoint(final Collection&lt;? extends Point&gt; points) {
<span class="nc" id="L771">    return createMultiPoint(points, null);</span>
  }

  /**
   * Creates a MultiPoint using the given Points. A null or empty collection will create an empty
   * MultiPoint.
   *
   * @param points          the points of the {@link MultiPoint}
   * @param geometryFactory the geometry factory to use
   * @return the {@link MultiPoint}
   */
  @SuppressWarnings(&quot;SameParameterValue&quot;)
  public static MultiPoint createMultiPoint(final Collection&lt;? extends Point&gt; points,
      final GeometryFactory geometryFactory) {
    Point[] ps;
<span class="nc bnc" id="L786" title="All 2 branches missed.">    if (points == null) {</span>
<span class="nc" id="L787">      ps = null;</span>
    } else {
<span class="nc" id="L789">      ps = points.toArray(new Point[0]);</span>
    }
<span class="nc bnc" id="L791" title="All 2 branches missed.">    final GeometryFactory gf = geometryFactory == null ? DEFAULT_GEOMETRY_FACTORY : geometryFactory;</span>
<span class="nc" id="L792">    return gf.createMultiPoint(ps);</span>
  }

  /**
   * Creates a LineString using the given coordinates; a null or empty collection will create an
   * empty LineString. Consecutive points must not be equal.
   *
   * @param coordinates the coordinates of the {@link LineString}
   * @return the {@link LineString}
   */
  public static LineString createLineString(final Collection&lt;? extends Coordinate&gt; coordinates) {
<span class="nc" id="L803">    return createLineString(coordinates, null);</span>
  }

  /**
   * Creates a LineString using the given coordinates; a null or empty collection will create an
   * empty LineString. Consecutive points must not be equal.
   *
   * @param coordinates     the coordinates of the {@link LineString}
   * @param geometryFactory the geometry factory to use
   * @return the {@link LineString}
   */
  public static LineString createLineString(final Collection&lt;? extends Coordinate&gt; coordinates,
      @SuppressWarnings(&quot;SameParameterValue&quot;) final GeometryFactory geometryFactory) {
    CoordinateSequence points;
<span class="nc bnc" id="L817" title="All 2 branches missed.">    if (coordinates == null) {</span>
<span class="nc" id="L818">      points = null;</span>
    } else {
<span class="nc" id="L820">      Coordinate[] coords = coordinates.toArray(new Coordinate[0]);</span>
<span class="nc" id="L821">      points = CoordinateArraySequenceFactory.instance().create(coords);</span>
    }
<span class="nc bnc" id="L823" title="All 2 branches missed.">    final GeometryFactory gf = geometryFactory == null ? DEFAULT_GEOMETRY_FACTORY : geometryFactory;</span>
<span class="nc" id="L824">    return gf.createLineString(points);</span>
  }

  /**
   * Creates a MultiLineString using the given LineStrings; a null or empty collection will create
   * an empty MultiLineString.
   *
   * @param lineStrings the {@link LineString}s of the {@link MultiLineString}
   * @return the {@link MultiLineString}
   */
  public static MultiLineString createMultiLineString(
      final Collection&lt;? extends LineString&gt; lineStrings) {
<span class="nc" id="L836">    return createMultiLineString(lineStrings, null);</span>
  }

  /**
   * Creates a MultiLineString using the given LineStrings; a null or empty collection will create
   * an empty MultiLineString.
   *
   * @param lineStrings     the {@link LineString}s of the {@link MultiLineString}
   * @param geometryFactory the geometry factory to use
   * @return the {@link MultiLineString}
   */
  public static MultiLineString createMultiLineString(
      final Collection&lt;? extends LineString&gt; lineStrings,
      @SuppressWarnings(&quot;SameParameterValue&quot;) final GeometryFactory geometryFactory) {
    LineString[] lines;
<span class="nc bnc" id="L851" title="All 2 branches missed.">    if (lineStrings == null) {</span>
<span class="nc" id="L852">      lines = null;</span>
    } else {
<span class="nc" id="L854">      lines = lineStrings.toArray(new LineString[0]);</span>
    }
<span class="nc bnc" id="L856" title="All 2 branches missed.">    final GeometryFactory gf = geometryFactory == null ? DEFAULT_GEOMETRY_FACTORY : geometryFactory;</span>
<span class="nc" id="L857">    return gf.createMultiLineString(lines);</span>
  }

  /**
   * Creates a LinearRing using the given coordinates. A null or empty coordinates will create an
   * empty LinearRing.
   *
   * @param coordinates the coordinates
   * @return the created LinearRing
   */
  public static LinearRing createLinearRing(final Collection&lt;? extends Coordinate&gt; coordinates) {
<span class="nc" id="L868">    return createLinearRing(coordinates, null);</span>
  }

  /**
   * Creates a LinearRing using the given coordinates. A null or empty coordinates will create an
   * empty LinearRing.
   *
   * @param coordinates     the coordinates
   * @param geometryFactory the geometry factory
   * @return the created LinearRing
   */
  public static LinearRing createLinearRing(final Collection&lt;? extends Coordinate&gt; coordinates,
      @SuppressWarnings(&quot;SameParameterValue&quot;) final GeometryFactory geometryFactory) {
    CoordinateSequence points;
<span class="nc bnc" id="L882" title="All 2 branches missed.">    if (coordinates == null) {</span>
<span class="nc" id="L883">      points = null;</span>
    } else {
<span class="nc" id="L885">      Coordinate[] coords = coordinates.toArray(new Coordinate[0]);</span>
<span class="nc bnc" id="L886" title="All 2 branches missed.">      if (coords.length &gt; 0) {</span>
<span class="nc" id="L887">        Coordinate coord0 = coords[0];</span>
<span class="nc" id="L888">        Coordinate coordN = coords[coords.length - 1];</span>
<span class="nc bnc" id="L889" title="All 2 branches missed.">        if (!coord0.equals3D(coordN)) {</span>
<span class="nc" id="L890">          coords = Arrays.copyOf(coords, coords.length + 1);</span>
<span class="nc" id="L891">          coords[coords.length - 1] = (Coordinate) coord0.clone();</span>
        }
      }
<span class="nc" id="L894">      points = CoordinateArraySequenceFactory.instance().create(coords);</span>
    }
<span class="nc bnc" id="L896" title="All 2 branches missed.">    final GeometryFactory gf = geometryFactory == null ? DEFAULT_GEOMETRY_FACTORY : geometryFactory;</span>
<span class="nc" id="L897">    return gf.createLinearRing(points);</span>
  }

  /**
   * Constructs a Polygon with the given exterior boundary.
   *
   * @param shell the outer boundary of the new Polygon, or null or an empty LinearRing if the empty
   *              geometry is to be created
   * @return the created Polygon
   */
  public static Polygon createPolygon(final LinearRing shell) {
<span class="nc" id="L908">    return createPolygon(shell, null, null);</span>
  }

  /**
   * Constructs a Polygon with the given exterior boundary.
   *
   * @param shell           the outer boundary of the new Polygon, or null or an empty LinearRing if
   *                        the empty geometry is to be created
   * @param geometryFactory the geometry factory
   * @return the created Polygon
   */
  public static Polygon createPolygon(final LinearRing shell,
      final GeometryFactory geometryFactory) {
<span class="nc" id="L921">    return createPolygon(shell, null, geometryFactory);</span>
  }

  /**
   * Constructs a Polygon with the given exterior boundary and interior boundaries.
   *
   * @param shell the outer boundary of the new Polygon, or null or an empty LinearRing if the empty
   *              geometry is to be created
   * @param holes the inner boundaries of the new Polygon, or null or empty LinearRing s if the
   *              empty geometry is to be created
   * @return the created Polygon
   */
  public static Polygon createPolygon(final LinearRing shell,
      final Collection&lt;? extends LinearRing&gt; holes) {
<span class="nc" id="L935">    return createPolygon(shell, holes, null);</span>
  }

  /**
   * Constructs a Polygon with the given exterior boundary and interior boundaries.
   *
   * @param shell           the outer boundary of the new Polygon, or null or an empty LinearRing if
   *                        the empty geometry is to be created
   * @param holes           the inner boundaries of the new Polygon, or null or empty LinearRing s
   *                        if the empty geometry is to be created
   * @param geometryFactory the geometry factory
   * @return the created Polygon
   */
  public static Polygon createPolygon(final LinearRing shell,
      final Collection&lt;? extends LinearRing&gt; holes,
      final GeometryFactory geometryFactory) {
    LinearRing[] hs;
<span class="nc bnc" id="L952" title="All 2 branches missed.">    if (holes == null) {</span>
<span class="nc" id="L953">      hs = null;</span>
    } else {
<span class="nc" id="L955">      hs = holes.toArray(new LinearRing[0]);</span>
    }
<span class="nc bnc" id="L957" title="All 2 branches missed.">    final GeometryFactory gf = geometryFactory == null ? DEFAULT_GEOMETRY_FACTORY : geometryFactory;</span>
<span class="nc" id="L958">    return gf.createPolygon(shell, hs);</span>
  }

  /**
   * Creates a MultiPolygon using the given Polygons; a null or empty array will create an empty
   * Polygon.
   *
   * @param polygons the polygons
   * @return the multi polygon
   */
  public static MultiPolygon createMultiPolygon(final Collection&lt;? extends Polygon&gt; polygons) {
<span class="nc" id="L969">    return createMultiPolygon(polygons, null);</span>
  }

  /**
   * Creates a MultiPolygon using the given Polygons; a null or empty array will create an empty
   * Polygon.
   *
   * @param polygons        the polygons
   * @param geometryFactory the geometry factory
   * @return the multi polygon
   */
  public static MultiPolygon createMultiPolygon(final Collection&lt;? extends Polygon&gt; polygons,
      @SuppressWarnings(&quot;SameParameterValue&quot;) final GeometryFactory geometryFactory) {
    Polygon[] ps;
<span class="nc bnc" id="L983" title="All 2 branches missed.">    if (polygons == null) {</span>
<span class="nc" id="L984">      ps = null;</span>
    } else {
<span class="nc" id="L986">      ps = polygons.toArray(new Polygon[0]);</span>
    }
<span class="nc bnc" id="L988" title="All 2 branches missed.">    final GeometryFactory gf = geometryFactory == null ? DEFAULT_GEOMETRY_FACTORY : geometryFactory;</span>
<span class="nc" id="L989">    return gf.createMultiPolygon(ps);</span>
  }

  /**
   * Transforms the coordinates of the given geometry from WGS84 into mercator.
   *
   * @param geometry the geometry
   * @return the transformed (cloned) geometry
   */
  public static Geometry transformWgs84ToMercator(final Geometry geometry) {
<span class="nc bnc" id="L999" title="All 2 branches missed.">    if (geometry == null) {</span>
<span class="nc" id="L1000">      return null;</span>
    }
<span class="nc" id="L1002">    Geometry result = geometry.copy();</span>
<span class="nc" id="L1003">    result.apply(new Wgs84ToMercatorCoordinateFilter());</span>
<span class="nc" id="L1004">    return result;</span>
  }

  /**
   * Transforms the coordinates of the given geometry from mercator into WGS84.
   *
   * @param geometry the geometry
   * @return the transformed (cloned) geometry
   */
  public static Geometry transformMercatorToWgs84(final Geometry geometry) {
<span class="nc bnc" id="L1014" title="All 2 branches missed.">    if (geometry == null) {</span>
<span class="nc" id="L1015">      return null;</span>
    }
<span class="nc" id="L1017">    Geometry result = geometry.copy();</span>
<span class="nc" id="L1018">    result.apply(new MercatorToWgs84CoordinateFilter());</span>
<span class="nc" id="L1019">    return result;</span>
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>